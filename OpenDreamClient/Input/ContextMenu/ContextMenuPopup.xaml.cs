using OpenDreamClient.Interface;
using OpenDreamClient.Interface.Controls.UI;
using OpenDreamClient.Rendering;
using OpenDreamShared.Dream;
using OpenDreamShared.Rendering;
using Robust.Client.AutoGenerated;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;

namespace OpenDreamClient.Input.ContextMenu;

[GenerateTypedNameReferences]
internal sealed partial class ContextMenuPopup : Popup {
    [Dependency] private readonly IPlayerManager _playerManager = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IEntitySystemManager _entitySystemManager = default!;
    [Dependency] private readonly IUserInterfaceManager _uiManager = default!;
    private readonly ClientAppearanceSystem _appearanceSystem;
    private readonly DreamClientSystem _dreamClientSystem;
    private readonly ClientVerbSystem _verbSystem;
    private readonly DMISpriteSystem _spriteSystem;
    private readonly EntityLookupSystem _lookupSystem;
    private readonly MouseInputSystem _mouseInputSystem;
    private readonly EntityQuery<DMISpriteComponent> _spriteQuery;
    private readonly EntityQuery<TransformComponent> _xformQuery;
    private readonly EntityQuery<DreamMobSightComponent> _mobSightQuery;

    public int EntityCount => ContextMenu.ChildCount;

    private VerbMenuPopup? _currentVerbMenu;

    public ContextMenuPopup() {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _verbSystem = _entitySystemManager.GetEntitySystem<ClientVerbSystem>();
        _appearanceSystem = _entitySystemManager.GetEntitySystem<ClientAppearanceSystem>();
        _dreamClientSystem = _entitySystemManager.GetEntitySystem<DreamClientSystem>();
        _spriteSystem = _entitySystemManager.GetEntitySystem<DMISpriteSystem>();
        _lookupSystem = _entitySystemManager.GetEntitySystem<EntityLookupSystem>();
        _mouseInputSystem = _entitySystemManager.GetEntitySystem<MouseInputSystem>();
        _spriteQuery = _entityManager.GetEntityQuery<DMISpriteComponent>();
        _xformQuery = _entityManager.GetEntityQuery<TransformComponent>();
        _mobSightQuery = _entityManager.GetEntityQuery<DreamMobSightComponent>();
    }

    public void RepopulateEntities(ScalingViewport viewport, Vector2 relativePos, ScreenCoordinates pointerLocation) {
        ContextMenu.RemoveAllChildren();

        var mapCoords = viewport.ScreenToMap(pointerLocation.Position);
        var entities = _lookupSystem.GetEntitiesInRange(mapCoords, 0.01f, LookupFlags.Uncontained | LookupFlags.Approximate);

        foreach (var uid in entities) {
            if (_xformQuery.TryGetComponent(uid, out var transform) && !_entityManager.HasComponent<MapGridComponent>(transform.ParentUid)) // Not a child of another entity
                continue;
            if (!_spriteQuery.TryGetComponent(uid, out var sprite)) // Has a sprite
                continue;
            if (sprite.Icon.Appearance?.MouseOpacity == MouseOpacity.Transparent) // Not transparent to mouse clicks
                continue;
            if (!_spriteSystem.IsVisible(sprite, transform, GetSeeInvisible(), null)) // Not invisible
                continue;

            var reference = new ClientObjectReference(_entityManager.GetNetEntity(uid));
            var name = _appearanceSystem.GetName(reference);
            ContextMenu.AddChild(new ContextMenuItem(this, reference, name, sprite.Icon));
        }

        // Add the screen object directly under the mouse, if any
        var atomUnderMouse = _mouseInputSystem.GetAtomUnderMouse(viewport, relativePos, pointerLocation);
        if (atomUnderMouse is { IsScreen: true }) {
            var uid = _entityManager.GetEntity(atomUnderMouse.Value.Atom.Entity);

            if (_spriteQuery.TryGetComponent(uid, out var sprite) &&
                sprite.Icon.Appearance?.MouseOpacity != MouseOpacity.Transparent) {
                var reference = new ClientObjectReference(_entityManager.GetNetEntity(uid));
                var name = _appearanceSystem.GetName(reference);
                ContextMenu.AddChild(new ContextMenuItem(this, reference, name, sprite.Icon));
            }
        }

        // Append the turf to the end of the context menu
        var turfUnderMouse = _mouseInputSystem.GetTurfUnderMouse(mapCoords, out var turfId)?.Atom;
        if (turfUnderMouse is not null && turfId is not null) {
            var name = _appearanceSystem.GetName(turfUnderMouse.Value);
            var icon = _appearanceSystem.GetTurfIcon(turfId.Value);

            ContextMenu.AddChild(new ContextMenuItem(this, turfUnderMouse.Value, name, icon));
        }

        //TODO filter entities by the valid verbs that exist on them
        //they should only show up if there is a verb attached to usr which matches the filter in world syntax
        //ie, obj|turf in world
        //note that popup_menu = 0 overrides this behaviour, as does verb invisibility (urgh), and also hidden
        //because BYOND sure loves redundancy
    }

    public void SetActiveItem(ContextMenuItem item) {
        if (_currentVerbMenu != null) {
            _currentVerbMenu.Close();
            _uiManager.ModalRoot.RemoveChild(_currentVerbMenu);
        }

        _currentVerbMenu = new VerbMenuPopup(_verbSystem, GetSeeInvisible(), item.Target);

        _currentVerbMenu.OnVerbSelected += Close;

        Vector2 desiredSize = _currentVerbMenu.DesiredSize;
        Vector2 verbMenuPos = item.GlobalPosition with { X = item.GlobalPosition.X + item.Size.X };
        _uiManager.ModalRoot.AddChild(_currentVerbMenu);
        _currentVerbMenu.Open(UIBox2.FromDimensions(verbMenuPos, desiredSize));
    }

    /// <returns>The see_invisible of our current mob</returns>
    private sbyte GetSeeInvisible() {
        if (_playerManager.LocalSession == null)
            return 127;
        if (!_mobSightQuery.TryGetComponent(_dreamClientSystem.MobUid, out DreamMobSightComponent? sight))
            return 127;

        return sight.SeeInvisibility;
    }
}
